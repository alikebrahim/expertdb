"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aiAPI: () => (/* binding */ aiAPI),\n/* harmony export */   authAPI: () => (/* binding */ authAPI),\n/* harmony export */   expertAPI: () => (/* binding */ expertAPI),\n/* harmony export */   statisticsAPI: () => (/* binding */ statisticsAPI)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// API endpoints\nconst API_URL = '/api';\n// Get the API URL from environment or use default\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';\n// Axios instance\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_URL,\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    // Add timeout to prevent hanging requests\n    timeout: 15000\n});\n// Add Authorization header with JWT token if available\napiClient.interceptors.request.use((config)=>{\n    if (true) {\n        // Only add token if we're not on the login page\n        if (window.location.pathname !== '/login') {\n            const token = localStorage.getItem('token');\n            if (token) {\n                config.headers.Authorization = \"Bearer \".concat(token);\n            } else if (window.location.pathname !== '/') {\n                // If no token and not on login or homepage, redirect to login\n                window.location.href = '/login';\n                return Promise.reject(new Error('No authentication token found'));\n            }\n        }\n    }\n    return config;\n}, (error)=>Promise.reject(error));\n// Expert API functions\nconst expertAPI = {\n    // Get all experts with optional filters, pagination and sorting\n    getAllExperts: async function(filters) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, sortBy = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'name', sortOrder = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 'asc';\n        const params = new URLSearchParams();\n        // Add pagination parameters\n        params.append('limit', String(limit));\n        params.append('offset', String(offset));\n        // Add sorting parameters\n        if (sortBy) {\n            params.append('sort_by', sortBy);\n            params.append('sort_order', sortOrder);\n        }\n        // Add filters\n        if (filters) {\n            Object.entries(filters).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined && value !== null && value !== '') {\n                    params.append(key, String(value));\n                }\n            });\n        }\n        const response = await apiClient.get(\"/experts?\".concat(params.toString()));\n        return {\n            experts: response.data,\n            pagination: {\n                limit,\n                offset,\n                total: parseInt(response.headers['x-total-count'] || '0')\n            }\n        };\n    },\n    // Get expert by ID\n    getExpertById: async (id)=>{\n        const response = await apiClient.get(\"/experts/\".concat(id));\n        return response.data;\n    },\n    // Create expert request\n    createExpertRequest: async (expertRequest)=>{\n        const response = await apiClient.post('/expert-requests', expertRequest);\n        return response.data;\n    },\n    // Get ISCED classification data\n    getISCEDLevels: async ()=>{\n        const response = await apiClient.get('/isced/levels');\n        return response.data;\n    },\n    getISCEDFields: async ()=>{\n        const response = await apiClient.get('/isced/fields');\n        return response.data;\n    },\n    // Engagement operations\n    getExpertEngagements: async (expertId)=>{\n        const response = await apiClient.get(\"/experts/\".concat(expertId, \"/engagements\"));\n        return response.data;\n    },\n    createEngagement: async (engagement)=>{\n        const response = await apiClient.post('/engagements', engagement);\n        return response.data;\n    },\n    updateEngagement: async (id, engagement)=>{\n        const response = await apiClient.put(\"/engagements/\".concat(id), engagement);\n        return response.data;\n    },\n    deleteEngagement: async (id)=>{\n        const response = await apiClient.delete(\"/engagements/\".concat(id));\n        return response.data;\n    }\n};\n// AI Panel Suggestion API\nconst aiAPI = {\n    suggestExpertPanel: async function(projectName, iscedFieldId) {\n        let numExperts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;\n        const response = await apiClient.post('/ai/suggest-panel', {\n            projectName,\n            iscedFieldId: iscedFieldId || undefined,\n            numExperts\n        });\n        return response.data;\n    }\n};\n// Statistics API\nconst statisticsAPI = {\n    // Get all statistics\n    getAllStatistics: async ()=>{\n        const response = await apiClient.get('/statistics');\n        return response.data;\n    },\n    // Get nationality statistics\n    getNationalityStats: async ()=>{\n        const response = await apiClient.get('/statistics/nationality');\n        return response.data;\n    },\n    // Get ISCED statistics\n    getISCEDStats: async ()=>{\n        const response = await apiClient.get('/statistics/isced');\n        return response.data;\n    },\n    // Get engagement statistics\n    getEngagementStats: async ()=>{\n        const response = await apiClient.get('/statistics/engagements');\n        return response.data;\n    },\n    // Get growth statistics\n    getGrowthStats: async function() {\n        let months = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 12;\n        const response = await apiClient.get(\"/statistics/growth?months=\".concat(months));\n        return response.data;\n    }\n};\n// Authentication API\nconst authAPI = {\n    login: async (email, password)=>{\n        try {\n            // Try direct URL if API proxy fails\n            const fallbackClient = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n                baseURL: API_BASE_URL,\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                timeout: 15000\n            });\n            // First try with the regular API client (using proxy)\n            try {\n                const response = await apiClient.post('/auth/login', {\n                    email,\n                    password\n                });\n                return response.data;\n            } catch (proxyError) {\n                // Fallback to direct URL if proxy fails\n                const directResponse = await fallbackClient.post('/api/auth/login', {\n                    email,\n                    password\n                });\n                return directResponse.data;\n            }\n        } catch (error) {\n            throw error;\n        }\n    },\n    logout: ()=>{\n        localStorage.removeItem('token');\n        localStorage.removeItem('user');\n        // Trigger storage event for cross-tab communication\n        window.dispatchEvent(new Event('storage'));\n    },\n    getUser: ()=>{\n        if (false) {}\n        try {\n            const user = localStorage.getItem('user');\n            return user ? JSON.parse(user) : null;\n        } catch (error) {\n            console.error('Error parsing user from localStorage:', error);\n            return null;\n        }\n    },\n    isAuthenticated: ()=>{\n        if (false) {}\n        return !!localStorage.getItem('token');\n    }\n};\n// Error handler middleware for Axios\napiClient.interceptors.response.use((response)=>response, (error)=>{\n    var _error_response;\n    // Log detailed error information for debugging\n    if (error.response) {\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        console.error('API Error Response:', {\n            status: error.response.status,\n            headers: error.response.headers,\n            data: error.response.data\n        });\n    } else if (error.request) {\n        // The request was made but no response was received\n        console.error('API No Response:', error.request);\n    } else {\n        // Something happened in setting up the request that triggered an Error\n        console.error('API Request Error:', error.message);\n    }\n    // Handle authentication errors\n    if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401 && \"object\" !== 'undefined') {\n        console.log('Authentication error detected, logging out user');\n        localStorage.removeItem('token');\n        localStorage.removeItem('user');\n        // Use a more controlled redirect that doesn't interfere with the current operation\n        setTimeout(()=>{\n            window.location.href = '/login';\n        }, 100);\n    }\n    return Promise.reject(error);\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGFBQWtCLGFBQWE7UUFDbkVGLFFBQVFJLEdBQUcsQ0FBQztRQUNaL0UsYUFBYW9FLFVBQVUsQ0FBQztRQUN4QnBFLGFBQWFvRSxVQUFVLENBQUM7UUFFeEIsbUZBQW1GO1FBQ25GWSxXQUFXO1lBQ1RwRixPQUFPQyxRQUFRLENBQUNNLElBQUksR0FBRztRQUN6QixHQUFHO0lBQ0w7SUFFQSxPQUFPQyxRQUFRQyxNQUFNLENBQUNFO0FBQ3hCIiwic291cmNlcyI6WyIvaG9tZS9hbGlrZWJyYWhpbS9kZXYvZXhwZXJ0ZGJfbmV3L2Zyb250ZW5kL2xpYi9hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuLy8gVHlwZXMgYmFzZWQgb24gYmFja2VuZCBzdHJ1Y3R1cmVzXG5leHBvcnQgaW50ZXJmYWNlIEVuZ2FnZW1lbnQge1xuICBpZDogbnVtYmVyO1xuICBleHBlcnRJZDogbnVtYmVyO1xuICBlbmdhZ2VtZW50VHlwZTogc3RyaW5nO1xuICBzdGFydERhdGU6IHN0cmluZztcbiAgZW5kRGF0ZT86IHN0cmluZztcbiAgcHJvamVjdE5hbWU/OiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICBmZWVkYmFja1Njb3JlPzogbnVtYmVyO1xuICBub3Rlcz86IHN0cmluZztcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwZXJ0IHtcbiAgaWQ6IG51bWJlcjtcbiAgZXhwZXJ0SWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNpZ25hdGlvbjogc3RyaW5nO1xuICBpbnN0aXR1dGlvbjogc3RyaW5nO1xuICBpc0JhaHJhaW5pOiBib29sZWFuO1xuICBuYXRpb25hbGl0eTogc3RyaW5nO1xuICBpc0F2YWlsYWJsZTogYm9vbGVhbjtcbiAgcmF0aW5nOiBzdHJpbmc7XG4gIHJvbGU6IHN0cmluZztcbiAgZW1wbG95bWVudFR5cGU6IHN0cmluZztcbiAgZ2VuZXJhbEFyZWE6IHN0cmluZztcbiAgc3BlY2lhbGl6ZWRBcmVhOiBzdHJpbmc7XG4gIGlzVHJhaW5lZDogYm9vbGVhbjtcbiAgY3ZQYXRoOiBzdHJpbmc7XG4gIHBob25lOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGlzUHVibGlzaGVkOiBib29sZWFuO1xuICBpc2NlZExldmVsPzoge1xuICAgIGlkOiBudW1iZXI7XG4gICAgY29kZTogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgfTtcbiAgaXNjZWRGaWVsZD86IHtcbiAgICBpZDogbnVtYmVyO1xuICAgIGJyb2FkQ29kZTogc3RyaW5nO1xuICAgIGJyb2FkTmFtZTogc3RyaW5nO1xuICAgIG5hcnJvd0NvZGU/OiBzdHJpbmc7XG4gICAgbmFycm93TmFtZT86IHN0cmluZztcbiAgICBkZXRhaWxlZENvZGU/OiBzdHJpbmc7XG4gICAgZGV0YWlsZWROYW1lPzogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB9O1xuICBhcmVhcz86IEFycmF5PHtcbiAgICBpZDogbnVtYmVyO1xuICAgIG5hbWU6IHN0cmluZztcbiAgfT47XG4gIGVuZ2FnZW1lbnRzPzogRW5nYWdlbWVudFtdO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdXBkYXRlZEF0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGVydFJlcXVlc3Qge1xuICBpZD86IG51bWJlcjtcbiAgZXhwZXJ0SWQ/OiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzaWduYXRpb246IHN0cmluZztcbiAgaW5zdGl0dXRpb246IHN0cmluZztcbiAgaXNCYWhyYWluaTogYm9vbGVhbjtcbiAgaXNBdmFpbGFibGU6IGJvb2xlYW47XG4gIHJhdGluZz86IHN0cmluZztcbiAgcm9sZT86IHN0cmluZztcbiAgZW1wbG95bWVudFR5cGU/OiBzdHJpbmc7XG4gIGdlbmVyYWxBcmVhPzogc3RyaW5nO1xuICBzcGVjaWFsaXplZEFyZWE/OiBzdHJpbmc7XG4gIGlzVHJhaW5lZD86IGJvb2xlYW47XG4gIGN2UGF0aD86IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgaXNQdWJsaXNoZWQ/OiBib29sZWFuO1xuICBzdGF0dXM/OiBzdHJpbmc7XG4gIGNyZWF0ZWRBdD86IHN0cmluZztcbiAgcmV2aWV3ZWRBdD86IHN0cmluZztcbiAgcmV2aWV3ZWRCeT86IG51bWJlcjtcbn1cblxuLy8gQVBJIGVuZHBvaW50c1xuY29uc3QgQVBJX1VSTCA9ICcvYXBpJztcblxuLy8gR2V0IHRoZSBBUEkgVVJMIGZyb20gZW52aXJvbm1lbnQgb3IgdXNlIGRlZmF1bHRcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MCc7XG5cbi8vIEF4aW9zIGluc3RhbmNlXG5jb25zdCBhcGlDbGllbnQgPSBheGlvcy5jcmVhdGUoe1xuICBiYXNlVVJMOiBBUElfVVJMLFxuICBoZWFkZXJzOiB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgfSxcbiAgLy8gQWRkIHRpbWVvdXQgdG8gcHJldmVudCBoYW5naW5nIHJlcXVlc3RzXG4gIHRpbWVvdXQ6IDE1MDAwLFxufSk7XG5cbi8vIEFkZCBBdXRob3JpemF0aW9uIGhlYWRlciB3aXRoIEpXVCB0b2tlbiBpZiBhdmFpbGFibGVcbmFwaUNsaWVudC5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXG4gIChjb25maWcpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIE9ubHkgYWRkIHRva2VuIGlmIHdlJ3JlIG5vdCBvbiB0aGUgbG9naW4gcGFnZVxuICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSAhPT0gJy9sb2dpbicpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgY29uZmlnLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSAhPT0gJy8nKSB7XG4gICAgICAgICAgLy8gSWYgbm8gdG9rZW4gYW5kIG5vdCBvbiBsb2dpbiBvciBob21lcGFnZSwgcmVkaXJlY3QgdG8gbG9naW5cbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvbG9naW4nO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vIGF1dGhlbnRpY2F0aW9uIHRva2VuIGZvdW5kJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH0sXG4gIChlcnJvcikgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXG4pO1xuXG4vLyBFeHBlcnQgQVBJIGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGV4cGVydEFQSSA9IHtcbiAgLy8gR2V0IGFsbCBleHBlcnRzIHdpdGggb3B0aW9uYWwgZmlsdGVycywgcGFnaW5hdGlvbiBhbmQgc29ydGluZ1xuICBnZXRBbGxFeHBlcnRzOiBhc3luYyAoZmlsdGVycz86IFJlY29yZDxzdHJpbmcsIGFueT4sIGxpbWl0OiBudW1iZXIgPSAxMCwgb2Zmc2V0OiBudW1iZXIgPSAwLCBzb3J0Qnk6IHN0cmluZyA9ICduYW1lJywgc29ydE9yZGVyOiBzdHJpbmcgPSAnYXNjJykgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBcbiAgICAvLyBBZGQgcGFnaW5hdGlvbiBwYXJhbWV0ZXJzXG4gICAgcGFyYW1zLmFwcGVuZCgnbGltaXQnLCBTdHJpbmcobGltaXQpKTtcbiAgICBwYXJhbXMuYXBwZW5kKCdvZmZzZXQnLCBTdHJpbmcob2Zmc2V0KSk7XG4gICAgXG4gICAgLy8gQWRkIHNvcnRpbmcgcGFyYW1ldGVyc1xuICAgIGlmIChzb3J0QnkpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoJ3NvcnRfYnknLCBzb3J0QnkpO1xuICAgICAgcGFyYW1zLmFwcGVuZCgnc29ydF9vcmRlcicsIHNvcnRPcmRlcik7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBmaWx0ZXJzXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9leHBlcnRzPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cGVydHM6IHJlc3BvbnNlLmRhdGEsXG4gICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgIGxpbWl0LFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHRvdGFsOiBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzWyd4LXRvdGFsLWNvdW50J10gfHwgJzAnKSwgLy8gR2V0IHRvdGFsIGNvdW50IGZyb20gaGVhZGVyXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgXG4gIC8vIEdldCBleHBlcnQgYnkgSURcbiAgZ2V0RXhwZXJ0QnlJZDogYXN5bmMgKGlkOiBudW1iZXIpOiBQcm9taXNlPEV4cGVydD4gPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2V4cGVydHMvJHtpZH1gKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbiAgXG4gIC8vIENyZWF0ZSBleHBlcnQgcmVxdWVzdFxuICBjcmVhdGVFeHBlcnRSZXF1ZXN0OiBhc3luYyAoZXhwZXJ0UmVxdWVzdDogRXhwZXJ0UmVxdWVzdCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoJy9leHBlcnQtcmVxdWVzdHMnLCBleHBlcnRSZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbiAgXG4gIC8vIEdldCBJU0NFRCBjbGFzc2lmaWNhdGlvbiBkYXRhXG4gIGdldElTQ0VETGV2ZWxzOiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvaXNjZWQvbGV2ZWxzJyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG4gIFxuICBnZXRJU0NFREZpZWxkczogYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldCgnL2lzY2VkL2ZpZWxkcycpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgLy8gRW5nYWdlbWVudCBvcGVyYXRpb25zXG4gIGdldEV4cGVydEVuZ2FnZW1lbnRzOiBhc3luYyAoZXhwZXJ0SWQ6IG51bWJlcik6IFByb21pc2U8RW5nYWdlbWVudFtdPiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvZXhwZXJ0cy8ke2V4cGVydElkfS9lbmdhZ2VtZW50c2ApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgY3JlYXRlRW5nYWdlbWVudDogYXN5bmMgKGVuZ2FnZW1lbnQ6IE9taXQ8RW5nYWdlbWVudCwgJ2lkJyB8ICdjcmVhdGVkQXQnPikgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoJy9lbmdhZ2VtZW50cycsIGVuZ2FnZW1lbnQpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgdXBkYXRlRW5nYWdlbWVudDogYXN5bmMgKGlkOiBudW1iZXIsIGVuZ2FnZW1lbnQ6IFBhcnRpYWw8RW5nYWdlbWVudD4pID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoYC9lbmdhZ2VtZW50cy8ke2lkfWAsIGVuZ2FnZW1lbnQpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgZGVsZXRlRW5nYWdlbWVudDogYXN5bmMgKGlkOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9lbmdhZ2VtZW50cy8ke2lkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG59O1xuXG4vLyBBSSBQYW5lbCBTdWdnZXN0aW9uIEFQSVxuZXhwb3J0IGNvbnN0IGFpQVBJID0ge1xuICBzdWdnZXN0RXhwZXJ0UGFuZWw6IGFzeW5jIChwcm9qZWN0TmFtZTogc3RyaW5nLCBpc2NlZEZpZWxkSWQ/OiBudW1iZXIsIG51bUV4cGVydHM6IG51bWJlciA9IDMpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KCcvYWkvc3VnZ2VzdC1wYW5lbCcsIHtcbiAgICAgIHByb2plY3ROYW1lLFxuICAgICAgaXNjZWRGaWVsZElkOiBpc2NlZEZpZWxkSWQgfHwgdW5kZWZpbmVkLFxuICAgICAgbnVtRXhwZXJ0c1xuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG59O1xuXG4vLyBTdGF0aXN0aWNzIEFQSSB0eXBlc1xuZXhwb3J0IGludGVyZmFjZSBBcmVhU3RhdCB7XG4gIG5hbWU6IHN0cmluZztcbiAgY291bnQ6IG51bWJlcjtcbiAgcGVyY2VudGFnZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3d0aFN0YXQge1xuICBwZXJpb2Q6IHN0cmluZztcbiAgY291bnQ6IG51bWJlcjtcbiAgZ3Jvd3RoUmF0ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGVydFN0YXQge1xuICBleHBlcnRJZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGNvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF0aW9uYWxpdHlTdGF0cyB7XG4gIHRvdGFsOiBudW1iZXI7XG4gIGJhaHJhaW5pOiB7XG4gICAgY291bnQ6IG51bWJlcjtcbiAgICBwZXJjZW50YWdlOiBudW1iZXI7XG4gIH07XG4gIG5vbkJhaHJhaW5pOiB7XG4gICAgY291bnQ6IG51bWJlcjtcbiAgICBwZXJjZW50YWdlOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGlzdGljcyB7XG4gIHRvdGFsRXhwZXJ0czogbnVtYmVyO1xuICBiYWhyYWluaVBlcmNlbnRhZ2U6IG51bWJlcjtcbiAgdG9wQXJlYXM6IEFyZWFTdGF0W107XG4gIGV4cGVydHNCeUlTQ0VERmllbGQ6IEFyZWFTdGF0W107XG4gIGVuZ2FnZW1lbnRzQnlUeXBlOiBBcmVhU3RhdFtdO1xuICBtb250aGx5R3Jvd3RoOiBHcm93dGhTdGF0W107XG4gIG1vc3RSZXF1ZXN0ZWRFeHBlcnRzOiBFeHBlcnRTdGF0W107XG4gIGxhc3RVcGRhdGVkOiBzdHJpbmc7XG59XG5cbi8vIFN0YXRpc3RpY3MgQVBJXG5leHBvcnQgY29uc3Qgc3RhdGlzdGljc0FQSSA9IHtcbiAgLy8gR2V0IGFsbCBzdGF0aXN0aWNzXG4gIGdldEFsbFN0YXRpc3RpY3M6IGFzeW5jICgpOiBQcm9taXNlPFN0YXRpc3RpY3M+ID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9zdGF0aXN0aWNzJyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG4gIFxuICAvLyBHZXQgbmF0aW9uYWxpdHkgc3RhdGlzdGljc1xuICBnZXROYXRpb25hbGl0eVN0YXRzOiBhc3luYyAoKTogUHJvbWlzZTxOYXRpb25hbGl0eVN0YXRzPiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvc3RhdGlzdGljcy9uYXRpb25hbGl0eScpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgLy8gR2V0IElTQ0VEIHN0YXRpc3RpY3NcbiAgZ2V0SVNDRURTdGF0czogYXN5bmMgKCk6IFByb21pc2U8QXJlYVN0YXRbXT4gPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldCgnL3N0YXRpc3RpY3MvaXNjZWQnKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbiAgXG4gIC8vIEdldCBlbmdhZ2VtZW50IHN0YXRpc3RpY3NcbiAgZ2V0RW5nYWdlbWVudFN0YXRzOiBhc3luYyAoKTogUHJvbWlzZTxBcmVhU3RhdFtdPiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvc3RhdGlzdGljcy9lbmdhZ2VtZW50cycpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgLy8gR2V0IGdyb3d0aCBzdGF0aXN0aWNzXG4gIGdldEdyb3d0aFN0YXRzOiBhc3luYyAobW9udGhzOiBudW1iZXIgPSAxMik6IFByb21pc2U8R3Jvd3RoU3RhdFtdPiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvc3RhdGlzdGljcy9ncm93dGg/bW9udGhzPSR7bW9udGhzfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG59O1xuXG4vLyBBdXRoZW50aWNhdGlvbiBBUElcbmV4cG9ydCBjb25zdCBhdXRoQVBJID0ge1xuICBsb2dpbjogYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IGRpcmVjdCBVUkwgaWYgQVBJIHByb3h5IGZhaWxzXG4gICAgICBjb25zdCBmYWxsYmFja0NsaWVudCA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgICAgIGJhc2VVUkw6IEFQSV9CQVNFX1VSTCxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIHRpbWVvdXQ6IDE1MDAwXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gRmlyc3QgdHJ5IHdpdGggdGhlIHJlZ3VsYXIgQVBJIGNsaWVudCAodXNpbmcgcHJveHkpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KCcvYXV0aC9sb2dpbicsIHsgZW1haWwsIHBhc3N3b3JkIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gY2F0Y2ggKHByb3h5RXJyb3IpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZGlyZWN0IFVSTCBpZiBwcm94eSBmYWlsc1xuICAgICAgICBjb25zdCBkaXJlY3RSZXNwb25zZSA9IGF3YWl0IGZhbGxiYWNrQ2xpZW50LnBvc3QoJy9hcGkvYXV0aC9sb2dpbicsIHsgZW1haWwsIHBhc3N3b3JkIH0pO1xuICAgICAgICByZXR1cm4gZGlyZWN0UmVzcG9uc2UuZGF0YTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuICBcbiAgbG9nb3V0OiAoKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Rva2VuJyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXInKTtcbiAgICAvLyBUcmlnZ2VyIHN0b3JhZ2UgZXZlbnQgZm9yIGNyb3NzLXRhYiBjb21tdW5pY2F0aW9uXG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzdG9yYWdlJykpO1xuICB9LFxuICBcbiAgZ2V0VXNlcjogKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcicpO1xuICAgICAgcmV0dXJuIHVzZXIgPyBKU09OLnBhcnNlKHVzZXIpIDogbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyB1c2VyIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgXG4gIGlzQXV0aGVudGljYXRlZDogKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAhIWxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuICB9XG59O1xuXG4vLyBFcnJvciBoYW5kbGVyIG1pZGRsZXdhcmUgZm9yIEF4aW9zXG5hcGlDbGllbnQuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcbiAgKHJlc3BvbnNlKSA9PiByZXNwb25zZSxcbiAgKGVycm9yKSA9PiB7XG4gICAgLy8gTG9nIGRldGFpbGVkIGVycm9yIGluZm9ybWF0aW9uIGZvciBkZWJ1Z2dpbmdcbiAgICBpZiAoZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgIC8vIFRoZSByZXF1ZXN0IHdhcyBtYWRlIGFuZCB0aGUgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGEgc3RhdHVzIGNvZGVcbiAgICAgIC8vIHRoYXQgZmFsbHMgb3V0IG9mIHRoZSByYW5nZSBvZiAyeHhcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvciBSZXNwb25zZTonLCB7XG4gICAgICAgIHN0YXR1czogZXJyb3IucmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiBlcnJvci5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICBkYXRhOiBlcnJvci5yZXNwb25zZS5kYXRhLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChlcnJvci5yZXF1ZXN0KSB7XG4gICAgICAvLyBUaGUgcmVxdWVzdCB3YXMgbWFkZSBidXQgbm8gcmVzcG9uc2Ugd2FzIHJlY2VpdmVkXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgTm8gUmVzcG9uc2U6JywgZXJyb3IucmVxdWVzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvbWV0aGluZyBoYXBwZW5lZCBpbiBzZXR0aW5nIHVwIHRoZSByZXF1ZXN0IHRoYXQgdHJpZ2dlcmVkIGFuIEVycm9yXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgUmVxdWVzdCBFcnJvcjonLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIGF1dGhlbnRpY2F0aW9uIGVycm9yc1xuICAgIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDEgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoZW50aWNhdGlvbiBlcnJvciBkZXRlY3RlZCwgbG9nZ2luZyBvdXQgdXNlcicpO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Rva2VuJyk7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpO1xuICAgICAgXG4gICAgICAvLyBVc2UgYSBtb3JlIGNvbnRyb2xsZWQgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IGludGVyZmVyZSB3aXRoIHRoZSBjdXJyZW50IG9wZXJhdGlvblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9sb2dpbic7XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG4pOyJdLCJuYW1lcyI6WyJheGlvcyIsIkFQSV9VUkwiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImFwaUNsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJoZWFkZXJzIiwidGltZW91dCIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiQXV0aG9yaXphdGlvbiIsImhyZWYiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJlcnJvciIsImV4cGVydEFQSSIsImdldEFsbEV4cGVydHMiLCJmaWx0ZXJzIiwibGltaXQiLCJvZmZzZXQiLCJzb3J0QnkiLCJzb3J0T3JkZXIiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJTdHJpbmciLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwidW5kZWZpbmVkIiwicmVzcG9uc2UiLCJnZXQiLCJ0b1N0cmluZyIsImV4cGVydHMiLCJkYXRhIiwicGFnaW5hdGlvbiIsInRvdGFsIiwicGFyc2VJbnQiLCJnZXRFeHBlcnRCeUlkIiwiaWQiLCJjcmVhdGVFeHBlcnRSZXF1ZXN0IiwiZXhwZXJ0UmVxdWVzdCIsInBvc3QiLCJnZXRJU0NFRExldmVscyIsImdldElTQ0VERmllbGRzIiwiZ2V0RXhwZXJ0RW5nYWdlbWVudHMiLCJleHBlcnRJZCIsImNyZWF0ZUVuZ2FnZW1lbnQiLCJlbmdhZ2VtZW50IiwidXBkYXRlRW5nYWdlbWVudCIsInB1dCIsImRlbGV0ZUVuZ2FnZW1lbnQiLCJkZWxldGUiLCJhaUFQSSIsInN1Z2dlc3RFeHBlcnRQYW5lbCIsInByb2plY3ROYW1lIiwiaXNjZWRGaWVsZElkIiwibnVtRXhwZXJ0cyIsInN0YXRpc3RpY3NBUEkiLCJnZXRBbGxTdGF0aXN0aWNzIiwiZ2V0TmF0aW9uYWxpdHlTdGF0cyIsImdldElTQ0VEU3RhdHMiLCJnZXRFbmdhZ2VtZW50U3RhdHMiLCJnZXRHcm93dGhTdGF0cyIsIm1vbnRocyIsImF1dGhBUEkiLCJsb2dpbiIsImVtYWlsIiwicGFzc3dvcmQiLCJmYWxsYmFja0NsaWVudCIsInByb3h5RXJyb3IiLCJkaXJlY3RSZXNwb25zZSIsImxvZ291dCIsInJlbW92ZUl0ZW0iLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJnZXRVc2VyIiwidXNlciIsIkpTT04iLCJwYXJzZSIsImNvbnNvbGUiLCJpc0F1dGhlbnRpY2F0ZWQiLCJzdGF0dXMiLCJtZXNzYWdlIiwibG9nIiwic2V0VGltZW91dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});